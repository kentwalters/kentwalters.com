
<!DOCTYPE html>
<html lang="en-us">
<head>
    <meta charset="UTF-8">
    <title>Hi</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="icon" href="favicon.png">

    <link rel="stylesheet" href="css/styles.css">
</head>
<body>

  <div id="canvasContainer">
    <canvas id="canvas"></canvas>
    <div id='name'>
        <h1 >Kent Walters</h1>
        <p>Right now I work at <a href="https://retool.com/" target="_blank">Retool</a> in San Francisco.</p>
       
    </div>
    
    <div id="control"> 
      <h2 id="obs-label">Objects: </h2>
      <p id="fpsLabel">FPS: </p>

      <label>
        <input type="checkbox" id="gravityToggle" checked>
        Gravity
      </label>
      <!-- <br><button id="resetButton">Reset</button> -->

    </div>

  </div>
</body>

<style>
    #name {
        position: absolute;
        top: 18px;
        left: 36px;
    }
  #resetButton {
    margin-top: 8px; 
    padding: 4px;
    background-color: #c9ac88;
    border-radius: 4px;

  }
  * {
    font-family: monospace;
  }
  body {
    margin: 0px;
  }
  #canvas {
    width: 100%;
    height: 100%;
    background-color: #211a10;
  }
  p {
    margin: 0px;
  }
  h1, h2, label, p {
      color: #c9ac88;
    }
  input {
    margin-left: 0px !important;
  }
  .ball {
  width: var(--ball-diameter);
  height: var(--ball-diameter);
  border-radius: 50%;
  background-color: #cb475b;
  position: absolute;

  /* Simplified Box Shadow */
  box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.5);

  /* Linear Gradient for Light Effect */
  background-image: linear-gradient(to bottom left, rgba(255, 255, 255, 0.3), rgba(0, 0, 0, 0.2));
}
  h2 {
    margin-top: 0px;
  }

  #control {
    position: absolute;
    margin: 18px;
    padding:18px;
    bottom: 0px;
    right: 0px;
    background-color: #212410;
  }
  .ball-label {
    font-family: monospace;
    font-weight: bold;
    font-size: 12pt;
  }
</style>

<script>
  // amt of acceleration from gravity
  const GRAVITY_CONST = 1;

  // % of velocity lost in collision with walls
  const COLLISION_ENERGY_LOSS = 0.15;

  // how many times per s we'll re-render
  const FRAME_RATE = 100;

  const ELASTIC_COLLISIONS = true;
  let gravityEnabled = true; // Initially set to true

  const BALL_DIAMETER = 4; // Half the original size, which was 50
  const BALL_RADIUS = BALL_DIAMETER / 2;

  let lastFrameTime = Date.now();
  let frameCount = 0;
  let fps = 0;
  let canvas, ctx;



  // array of objects
  const universe = [];


  class Vector {
    // m/s
    velocity;
    // degrees
    direction;

    constructor(m, d) {
      m ? this.velocity = m : this.velocity = 0;
      d ? this.direction = d : this.direction = 0;
    }
  }

  class Ball {
    xPos;
    yPos;
    mass;
    vector;
    htmlElement;

    constructor(x, y, m, v, e) {
      this.xPos = x;
      this.yPos = y;
      this.mass = m;
      this.vector = v;
      this.htmlElement = e;
    }
  }
  const GRID_SIZE = 100; // Adjust this based on the canvas size and ball size
  let grid = [];

  function setupGrid() {
    grid = [];
    for (let i = 0; i < Math.ceil(canvas.width / GRID_SIZE); i++) {
      grid[i] = [];
      for (let j = 0; j < Math.ceil(canvas.height / GRID_SIZE); j++) {
        grid[i][j] = [];
      }
    }
  }


 const basicSetup = () => {
    canvas = document.getElementById("canvas");
    ctx = canvas.getContext("2d");
    document.documentElement.style.setProperty('--ball-diameter', `${BALL_DIAMETER}px`);
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    clickHandler();
    document.getElementById('gravityToggle').addEventListener('change', (event) => {
      gravityEnabled = event.target.checked;
    });

    window.addEventListener('resize', resizeCanvas);
  };

const clickHandler = () => {
  canvas.addEventListener("click", (e) => {
    const NUM_BALLS = 100; // Number of balls to create
    const RADIUS = 200;    // Radius of the circle of balls

    for (let i = 0; i < NUM_BALLS; i++) {
      const angle = (i / NUM_BALLS) * Math.PI * 2; // Divide the circle into 100 parts
      const x = e.clientX + RADIUS * Math.cos(angle) - BALL_RADIUS;
      const y = e.clientY + RADIUS * Math.sin(angle) - BALL_RADIUS;

      // Create a new Ball object
      const newBallObject = new Ball(
        x, y, 100, new Vector(0, 0)
      );
      universe.push(newBallObject);
    }
  });
};






  const createBallHtmlElement = () => {
    const ball = document.createElement("div");
    ball.classList.add("ball");
    const label = document.createElement('p');
    label.innerText = '';
    ball.appendChild(label)
    label.classList.add('ball-label')
    return ball;
  };

  const start = () => {
    basicSetup();
    setupGrid()
    setInterval(tick, 1000 / FRAME_RATE);
  };

  const tick = () => {
    move();
    render();
     frameCount++;

    const now = Date.now();
    const delta = now - lastFrameTime;

    if (delta >= 1000) { // Update FPS every second
        fps = frameCount;
        frameCount = 0;
        lastFrameTime = now;
        document.getElementById('fpsLabel').innerText = 'FPS: ' + fps;
    }
  };

  function applyGravity(ball, gravitationalConstant, timeStep) {
      // The velocity in X remains the same, as gravity only affects the Y component
      const velocityX = ball.vector.velocity * Math.cos(ball.vector.direction);

      // Gravity affects the velocity in Y. It should always pull down, hence adding the force.
      // Assuming downwards is the positive direction in Y-axis.
      const velocityY = ball.vector.velocity * Math.sin(ball.vector.direction) + gravitationalConstant * timeStep;

      // Update the ball's velocity vector with the new values
      ball.vector = new Vector(Math.sqrt(velocityX ** 2 + velocityY ** 2), Math.atan2(velocityY, velocityX));
  }

  function detectCollision(ball1, ball2) {
    const dx = ball1.xPos - ball2.xPos;
    const dy = ball1.yPos - ball2.yPos;
    const distance = Math.sqrt(dx * dx + dy * dy);

    return distance < BALL_DIAMETER; // Instead of 50

  }

function handleCollision(ball1, ball2) {
    // Calculate the difference in position
    const dx = ball2.xPos - ball1.xPos;
    const dy = ball2.yPos - ball1.yPos;

    // Calculate the distance between balls
    const distance = Math.sqrt(dx * dx + dy * dy);

    // Normal vector
    const nx = dx / distance;
    const ny = dy / distance;

    // Tangential vector
    const tx = -ny;
    const ty = nx;

    // Dot product tangent direction
    const dpTan1 = ball1.vector.velocity * Math.cos(ball1.vector.direction) * tx + ball1.vector.velocity * Math.sin(ball1.vector.direction) * ty;
    const dpTan2 = ball2.vector.velocity * Math.cos(ball2.vector.direction) * tx + ball2.vector.velocity * Math.sin(ball2.vector.direction) * ty;

    // Dot product normal direction
    const dpNorm1 = ball1.vector.velocity * Math.cos(ball1.vector.direction) * nx + ball1.vector.velocity * Math.sin(ball1.vector.direction) * ny;
    const dpNorm2 = ball2.vector.velocity * Math.cos(ball2.vector.direction) * nx + ball2.vector.velocity * Math.sin(ball2.vector.direction) * ny;

    // Conservation of momentum in 1D
    const m1 = (dpNorm1 * (ball1.mass - ball2.mass) + 2 * ball2.mass * dpNorm2) / (ball1.mass + ball2.mass);
    const m2 = (dpNorm2 * (ball2.mass - ball1.mass) + 2 * ball1.mass * dpNorm1) / (ball1.mass + ball2.mass);

    // Update ball velocities
    ball1.vector.velocity = Math.sqrt(m1 * m1 + dpTan1 * dpTan1);
    ball1.vector.direction = Math.atan2(m1 * ny + dpTan1 * ty, m1 * nx + dpTan1 * tx);

    ball2.vector.velocity = Math.sqrt(m2 * m2 + dpTan2 * dpTan2);
    ball2.vector.direction = Math.atan2(m2 * ny + dpTan2 * ty, m2 * nx + dpTan2 * tx);

    // Separate the balls slightly to avoid sticking

    if (distance < BALL_DIAMETER) {
        const overlap = 0.5 * (BALL_DIAMETER - distance);
        const nx = (ball2.xPos - ball1.xPos) / distance;
        const ny = (ball2.yPos - ball1.yPos) / distance;

        ball1.xPos -= overlap * nx;
        ball1.yPos -= overlap * ny;
        ball2.xPos += overlap * nx;
        ball2.yPos += overlap * ny;
    }
}

const resizeCanvas = () => {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
};



  function rotateVelocity(vector, angle) {
      const cos = Math.cos(angle);
      const sin = Math.sin(angle);
      const velocityX = vector.velocity * Math.cos(vector.direction);
      const velocityY = vector.velocity * Math.sin(vector.direction);

      return new Vector(
          velocityX * cos - velocityY * sin,
          velocityX * sin + velocityY * cos
      );
  }

const move = () => {
    setupGrid();
    const seconds = 1 / FRAME_RATE;

    for (let object of universe) {
      if (gravityEnabled) {
        const gravitationalConstant = 900.81; // m/s^2
        applyGravity(object, gravitationalConstant, seconds);
      }

      const distance = object.vector.velocity * seconds;
      let x2 = object.xPos + distance * Math.cos(object.vector.direction);
      let y2 = object.yPos + distance * Math.sin(object.vector.direction);

      // Check for wall collisions
      const rightEdge = x2 >= (canvas.width - BALL_DIAMETER);
      const leftEdge = x2 <= 0;
      const topEdge = y2 <= 0;
      const bottomEdge = y2 >= (canvas.height - BALL_DIAMETER);

      if (rightEdge || leftEdge) {
        object.vector.velocity *= (1 - COLLISION_ENERGY_LOSS); // Reduce velocity
        object.vector.direction = Math.PI - object.vector.direction;
        // Adjust ball position to stay within canvas
        x2 = rightEdge ? canvas.width - BALL_DIAMETER : (leftEdge ? 0 : x2);
      }

      if (topEdge || bottomEdge) {
        object.vector.velocity *= (1 - COLLISION_ENERGY_LOSS); // Reduce velocity
        object.vector.direction = -object.vector.direction;
        // Adjust ball position to stay within canvas
        y2 = bottomEdge ? canvas.height - BALL_DIAMETER : (topEdge ? 0 : y2);
      }

      // Assign new position to object
      object.xPos = x2;
      object.yPos = y2;


      // Place balls in grid

      let gridX = Math.floor(object.xPos / GRID_SIZE);
      let gridY = Math.floor(object.yPos / GRID_SIZE);
      
      if (gridX && gridY) grid[gridX][gridY].push(object);

      // Check collisions in grid
      for (let i = 0; i < grid.length; i++) {
        for (let j = 0; j < grid[i].length; j++) {
          let cell = grid[i][j];
          for (let k = 0; k < cell.length; k++) {
            for (let l = k + 1; l < cell.length; l++) {
              if (detectCollision(cell[k], cell[l])) {
                handleCollision(cell[k], cell[l]);
              }
            }
          }
        }
      }
    }
  }

  const render = () => {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    for (let ob of universe) {
      ctx.beginPath();
      ctx.arc(ob.xPos + BALL_RADIUS, ob.yPos + BALL_RADIUS, BALL_RADIUS, 0, Math.PI * 2);
      ctx.fillStyle = '#cb475b'; // Ball color
      ctx.fill();
      ctx.closePath();
    }

    document.getElementById('obs-label').innerText = `Objects: ${universe.length}`;
  };


  start();
</script>
